<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>IoT Dashboard - Smart Agriculture</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* ===(CSS sama persis seperti punyamu)=== */
    /* ... POTONGAN: gunakan CSS yang kamu kirim (tanpa perubahan) ... */
    /* agar jawaban ringkas, CSS tidak diulang di sini */
  </style>
</head>
<body>
  <!-- ===(HTML BODY sama persis seperti punyamu)=== -->
  <!-- ... POTONGAN: gunakan markup yang kamu kirim (tanpa perubahan) ... -->

  <!-- =================== SCRIPTS =================== -->
  <script>
    /* ================== KONFIG ================== */
    const API_BASE = ""; // kosong = origin yang sama (https://haris-iot.my.id/). Kalau beda, isi full base URL.
    const API_PATH = {
      realtime: (hours, device='esp32-1') => `${API_BASE}/get_realtime.php?hours=${hours}&device_id=${encodeURIComponent(device)}`,
      hourly:   (days,  device='esp32-1') => `${API_BASE}/get_hourly.php?days=${days}&device_id=${encodeURIComponent(device)}`
    };

    /* ================== STATE ================== */
    let mqttClient = null;
    let currentTheme = localStorage.getItem('theme') || 'light';
    let sensorData = { temperature: null, humidity: null, ph: null, pumpStatus: false };
    let scheduleData = {
      timeSchedule: { enabled: false, hour: 7, minute: 0, duration_min: 15, running: false, run_until: null },
      moistureControl: { enabled: false, threshold: 30, target: 70 }
    };
    let isConnected = false;

    let lastRelayCmd = { val: null, ts: 0 };
    const CMD_DEBOUNCE_MS = 700;

    let timeLeftTimer = null;

    // Historical (dipakai chart). Untuk tombol 1H/6H/24H/7D akan diisi via API.
    let historicalData = { temperature: [], humidity: [], ph: [], timestamps: [] };
    let chart = null;

    // MQTT (WSS TLS)
    const MQTT_CONFIG = {
      host: 'd61b7602f60d488a985eb51f2e8a7e65.s1.eu.hivemq.cloud',
      port: 8884,
      path: '/mqtt',
      protocol: 'wss',
      clientId: 'growy-dashboard-' + Math.random().toString(16).slice(2,10)
    };
    const MQTT_AUTH = { username: 'manunggal', password: 'Jayaa333' };
    const MQTT_TOPICS = {
      relaySet: 'growy/relay/set',
      relayState: 'growy/relay/state',
      scheduleSet: 'growy/relay/schedule/set',
      scheduleState: 'growy/relay/schedule/state',
      telemetry: 'growy/telemetry'
    };

    /* ================== INIT ================== */
    document.addEventListener('DOMContentLoaded', () => {
      initializeDashboard();
      initializeMQTT();
      // Muat historical default (1H) dari API
      setTimeout(()=>fetchHistorical('1h'), 200);
    });

    function initializeDashboard(){
      setTheme(currentTheme);
      byId('themeToggle')?.addEventListener('click', toggleTheme);
      byId('refreshBtn')?.addEventListener('click', refreshData);
      byId('reconnectBtn')?.addEventListener('click', reconnectMQTT);

      byId('scheduleTabs')?.addEventListener('click', (e) => {
        const btn = e.target.closest('.tab-btn'); if(!btn) return;
        switchTab(btn.dataset.tab);
      });

      byId('pumpToggle')?.addEventListener('change', function(){ togglePump(this.checked, true); });

      byId('setTimeSchedule')?.addEventListener('click', setTimeSchedule);
      byId('setMoistureControl')?.addEventListener('click', setMoistureControl);
      byId('timeScheduleEnable')?.addEventListener('change', function(){ if(!this.checked) disableTimeSchedule(); });
      byId('moistureAutoEnable')?.addEventListener('change', function(){ scheduleData.moistureControl.enabled=this.checked; updateMoistureStatus(); });

      document.querySelectorAll('.time-btn').forEach(btn=>btn.addEventListener('click', function(){
        document.querySelectorAll('.time-btn').forEach(b=>b.classList.remove('active'));
        this.classList.add('active');
        fetchHistorical(this.dataset.time);
      }));

      updateConnectionStatus('connecting');
      updateBrokerInfo();
      resetSensorDisplays();
      togglePump(sensorData.pumpStatus, false);
      updateLastUpdateTime();
      updateScheduleStatuses();
      initializeChart();
    }

    /* ================== Helper DOM ================== */
    const byId = (id)=>document.getElementById(id);

    function switchTab(tabName) {
      document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active'));
      const btn = document.querySelector(`.tab-btn[data-tab="${tabName}"]`); if (btn) btn.classList.add('active');
      document.querySelectorAll('.tab-content').forEach(c=>c.classList.remove('active'));
      const panel = byId(`${tabName}-tab`); if (panel) panel.classList.add('active');
    }

    function updateBrokerInfo() {
      const brokerEl = byId('brokerInfo');
      const clientEl = byId('clientId');
      if (brokerEl) brokerEl.textContent = `${MQTT_CONFIG.protocol}://${MQTT_CONFIG.host}:${MQTT_CONFIG.port}${MQTT_CONFIG.path}`;
      if (clientEl) clientEl.textContent = MQTT_CONFIG.clientId;
    }
    function reconnectMQTT(){ try{ mqttClient?.end(true);}catch(e){} setTimeout(initializeMQTT,600); }

    /* ================== MQTT ================== */
    function initializeMQTT() {
      try { mqttClient?.end(true); } catch(e) {}
      const url = `${MQTT_CONFIG.protocol}://${MQTT_CONFIG.host}:${MQTT_CONFIG.port}${MQTT_CONFIG.path}`;
      mqttClient = mqtt.connect(url, {
        clientId: MQTT_CONFIG.clientId, clean: true, connectTimeout: 10000,
        reconnectPeriod: 2000, keepalive: 30, username: MQTT_AUTH.username, password: MQTT_AUTH.password, protocolVersion: 4
      });

      mqttClient.on('connect', () => {
        isConnected = true;
        updateConnectionStatus('connected');
        byId('noDataWarning').style.display='none';
        mqttClient.subscribe([MQTT_TOPICS.relayState, MQTT_TOPICS.scheduleState, MQTT_TOPICS.telemetry]);
      });
      mqttClient.on('reconnect',()=>updateConnectionStatus('connecting'));
      mqttClient.on('error', ()=>disconnected());
      mqttClient.on('offline',()=>disconnected());
      mqttClient.on('close',  ()=>disconnected());
      mqttClient.on('message', handleMqttMessage);
    }
    function disconnected(){ isConnected=false; updateConnectionStatus('disconnected'); resetSensorDisplays(); stopTimeLeft(); }

    function handleMqttMessage(topic, msg) {
      let data; try { data = JSON.parse(msg.toString()); } catch(e){ return; }
      if (topic === MQTT_TOPICS.relayState){
        sensorData.pumpStatus = data.relay; togglePump(data.relay, false);
      } else if (topic === MQTT_TOPICS.scheduleState){
        scheduleData.timeSchedule = {
          enabled: !!data.enabled, hour: data.hour, minute: data.minute, duration_min: data.duration_min,
          running: !!data.running, run_until: (data.run_until ? Number(data.run_until) : null)
        };
        updateTimeScheduleStatus();
        handleTimeLeft(scheduleData.timeSchedule.running, scheduleData.timeSchedule.run_until);
      } else if (topic === MQTT_TOPICS.telemetry){
        if (data.suhu != null){ sensorData.temperature = data.suhu; updateTemperature(data.suhu); appendLivePoint('temperature', data.suhu); }
        if (data.ph   != null){ sensorData.ph         = data.ph;   updatePH(data.ph); appendLivePoint('ph', data.ph); }
        if (data.kelembapan_tanah != null){
          sensorData.humidity = data.kelembapan_tanah; updateHumidity(data.kelembapan_tanah); appendLivePoint('humidity', data.kelembapan_tanah);
        }
        if (data.relay !== undefined) { sensorData.pumpStatus = data.relay; togglePump(data.relay, false); }
        updateLastUpdateTime(); updateChart();
      }
    }

    function publishMqtt(topic, payload, retain=false) {
      if (mqttClient?.connected && isConnected) mqttClient.publish(topic, typeof payload==='string'?payload:JSON.stringify(payload), {qos:0, retain});
      else alert('MQTT not connected!');
    }

    function safePublishRelay(wantOn){
      const now=Date.now(); if (lastRelayCmd.val===wantOn && (now-lastRelayCmd.ts)<CMD_DEBOUNCE_MS) return;
      lastRelayCmd={val:wantOn,ts:now}; publishMqtt(MQTT_TOPICS.relaySet,{relay:!!wantOn},false);
    }

    /* ================== UI: Connection ================== */
    function updateConnectionStatus(status){
      const el = byId('connectionStatus'); if(!el) return;
      if(status==='connected'){ el.innerHTML='<i class="fas fa-wifi"></i><span>Connected</span>'; el.className='connection-status connected'; }
      else if(status==='disconnected'){ el.innerHTML='<i class="fas fa-exclamation-triangle"></i><span>Disconnected</span>'; el.className='connection-status disconnected'; }
      else{ el.innerHTML='<i class="fas fa-circle-notch fa-spin"></i><span>Connecting...</span>'; el.className='connection-status connecting'; }
    }

    /* ================== SENSOR UI ================== */
    function resetSensorDisplays(){
      byId('tempValue').textContent='--'; byId('humidityValue').textContent='--%'; byId('phValue').textContent='--';
      const ts=byId('tempStatus'), hs=byId('humidityStatus'), ps=byId('phStatus');
      if(ts){ ts.innerHTML='<i class="fas fa-question-circle"></i> No Data'; ts.className='status-badge normal'; }
      if(hs){ hs.innerHTML='<i class="fas fa-question-circle"></i> No Data'; hs.className='status-badge normal'; }
      if(ps){ ps.innerHTML='<i class="fas fa-question-circle"></i> No Data'; ps.className='status-badge normal'; }
      const pg=byId('humidityProgress'); if(pg){ const r=45,c=2*Math.PI*r; pg.style.strokeDashoffset=c; }
      const warn=byId('noDataWarning'); if(warn){ warn.style.display = isConnected ? 'none' : 'flex'; }
    }

    function updateTemperature(v){
      if(v==null) return; byId('tempValue').textContent=v.toFixed(1);
      const s=byId('tempStatus');
      if(s){ if(v<20) s.setAttribute('class','status-badge warning'), s.innerHTML='<i class="fas fa-snowflake"></i> Cold';
             else if(v>35) s.setAttribute('class','status-badge danger'), s.innerHTML='<i class="fas fa-fire"></i> Hot';
             else s.setAttribute('class','status-badge normal'), s.innerHTML='<i class="fas fa-check-circle"></i> Normal'; }
    }

    function updateHumidity(v){
      if(v==null) return;
      byId('humidityValue').textContent = v + '%';
      const r=45,c=2*Math.PI*r; byId('humidityProgress').style.strokeDashoffset = c - (v/100*c);
      const s=byId('humidityStatus');
      if(s){ if(v<30) s.setAttribute('class','status-badge danger'), s.innerHTML='<i class="fas fa-exclamation-triangle"></i> Dry';
             else if(v>80) s.setAttribute('class','status-badge warning'), s.innerHTML='<i class="fas fa-exclamation-circle"></i> Too Wet';
             else s.setAttribute('class','status-badge normal'), s.innerHTML='<i class="fas fa-check-circle"></i> Optimal'; }
    }

    function updatePH(v){
      if(v==null) return; byId('phValue').textContent=v.toFixed(1);
      const s=byId('phStatus');
      if(s){ if(v<6) s.setAttribute('class','status-badge warning'), s.innerHTML='<i class="fas fa-arrow-down"></i> Acidic';
             else if(v>8) s.setAttribute('class','status-badge warning'), s.innerHTML='<i class="fas fa-arrow-up"></i> Alkaline';
             else s.setAttribute('class','status-badge normal'), s.innerHTML='<i class="fas fa-balance-scale"></i> Balanced'; }
    }

    /* ================== RELAY ================== */
    function togglePump(isOn, shouldPublish=false){
      const st=byId('pumpStatus'), tg=byId('pumpToggle');
      if(tg) tg.checked=!!isOn;
      if(st){ st.className = isOn?'pump-status on':'pump-status off'; st.innerHTML=`<i class="fas fa-power-off"></i> PUMP ${isOn?'ON':'OFF'}`; }
      sensorData.pumpStatus=!!isOn;
      if(shouldPublish) safePublishRelay(!!isOn);
      updateLastUpdateTime();
    }

    /* ================== SCHEDULE ================== */
    function setTimeSchedule(){
      const enabled=byId('timeScheduleEnable').checked;
      const hour=parseInt(byId('scheduleHour').value), minute=parseInt(byId('scheduleMinute').value), dur=parseInt(byId('scheduleDuration').value);
      if(!enabled){ disableTimeSchedule(); return; }
      if([hour,minute,dur].some(isNaN)||hour<0||hour>23||minute<0||minute>59||dur<1){ alert('Please enter valid values'); return; }
      const payload={enable:true,hour,minute,duration_min:dur};
      scheduleData.timeSchedule={enabled:true,hour,minute,duration_min:dur,running:false,run_until:null};
      publishMqtt(MQTT_TOPICS.scheduleSet,payload,false);
      updateTimeScheduleStatus(); stopTimeLeft();
    }
    function disableTimeSchedule(){ publishMqtt(MQTT_TOPICS.scheduleSet,{enable:false,hour:0,minute:0,duration_min:0},false); scheduleData.timeSchedule.enabled=false; updateTimeScheduleStatus(); stopTimeLeft(); }

    function updateScheduleStatuses(){ updateTimeScheduleStatus(); updateMoistureStatus(); }
    function updateTimeScheduleStatus(){
      const el=byId('timeScheduleStatus'); if(!el) return;
      if(scheduleData.timeSchedule.enabled){
        const t = `${String(scheduleData.timeSchedule.hour).padStart(2,'0')}:${String(scheduleData.timeSchedule.minute).padStart(2,'0')}`;
        if(scheduleData.timeSchedule.running){ el.className='schedule-status running'; el.innerHTML=`<i class="fas fa-play-circle"></i> Schedule running - Started at ${t} for ${scheduleData.timeSchedule.duration_min} minutes`; }
        else { el.className='schedule-status active'; el.innerHTML=`<i class="fas fa-clock"></i> Schedule active - Will run at ${t} for ${scheduleData.timeSchedule.duration_min} minutes`; }
      } else { el.className='schedule-status inactive'; el.innerHTML='<i class="fas fa-clock"></i> No schedule set'; }
      const box=byId('timeLeftBox'); box.style.display=(scheduleData.timeSchedule.running && scheduleData.timeSchedule.run_until)?'block':'none';
    }
    function updateMoistureStatus(){
      const el=byId('moistureStatus'); if(!el) return;
      if(scheduleData.moistureControl.enabled){ el.className='schedule-status active'; el.innerHTML=`<i class="fas fa-tint"></i> Auto control active - ON < ${scheduleData.moistureControl.threshold}%, OFF > ${scheduleData.moistureControl.target}%`; }
      else { el.className='schedule-status inactive'; el.innerHTML='<i class="fas fa-tint"></i> Moisture automation disabled'; }
    }

    /* ===== Time Left ===== */
    function handleTimeLeft(running, runUntilEpochSec){ if(!running||!runUntilEpochSec){ stopTimeLeft(); return; } startTimeLeft(runUntilEpochSec); }
    function startTimeLeft(until){
      stopTimeLeft(); const box=byId('timeLeftBox'), txt=byId('timeLeftText'); if(!box||!txt) return; box.style.display='block';
      function tick(){ const remain=(until*1000)-Date.now(); if(remain<=0){ txt.textContent='Time left: 00:00:00 (Finished)'; stopTimeLeft(); return; }
        const hh=Math.floor(remain/3600000), mm=Math.floor((remain%3600000)/60000), ss=Math.floor((remain%60000)/1000);
        txt.textContent=`Time left: ${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`; }
      tick(); timeLeftTimer=setInterval(tick,1000);
    }
    function stopTimeLeft(){ if(timeLeftTimer){ clearInterval(timeLeftTimer); timeLeftTimer=null; } const box=byId('timeLeftBox'); if(box) box.style.display='none'; }

    /* ================== THEME & MISC ================== */
    function setTheme(theme){ document.documentElement.setAttribute('data-theme', theme); const icon=document.querySelector('#themeToggle i'); if(icon) icon.className=(theme==='dark'?'fas fa-sun':'fas fa-moon'); localStorage.setItem('theme', theme); }
    function toggleTheme(){ setTheme(document.documentElement.getAttribute('data-theme')==='light'?'dark':'light'); }
    function refreshData(){ const btn=byId('refreshBtn'); if(!btn) return; btn.classList.add('spinning'); setTimeout(()=>btn.classList.remove('spinning'), 800); }
    function updateLastUpdateTime(){ const el=byId('lastUpdate'); if(el) el.textContent = isConnected ? new Date().toLocaleString() : 'No connection'; }

    /* ================== CHARTS ================== */
    function initializeChart(){
      const ctx = document.getElementById('sensorChart').getContext('2d');
      chart = new Chart(ctx, {
        type:'line',
        data:{ labels:[], datasets:[
          { label:'Temperature (°C)', data:[], borderColor:'#ff6b6b', backgroundColor:'rgba(255,107,107,.1)', borderWidth:2, fill:false, tension:.3, yAxisID:'y' },
          { label:'Soil Moisture (%)', data:[], borderColor:'#4ecdc4', backgroundColor:'rgba(78,205,196,.1)', borderWidth:2, fill:false, tension:.3, yAxisID:'y1' },
          { label:'pH Level', data:[], borderColor:'#45b7d1', backgroundColor:'rgba(69,183,209,.1)', borderWidth:2, fill:false, tension:.3, yAxisID:'y2' }
        ]},
        options:{ responsive:true, maintainAspectRatio:false,
          scales:{ x:{ ticks:{maxTicksLimit:10} }, y:{ position:'left' }, y1:{ position:'right' }, y2:{ display:false, position:'right', min:0, max:14 } },
          interaction:{ mode:'index', intersect:false }, animation:{ duration:300 }
        }
      });
    }

    function setChartData(labels, tempArr, soilArr, phArr){
      historicalData = { timestamps:[...labels], temperature:[...tempArr], humidity:[...soilArr], ph:[...phArr] };
      chart.data.labels = labels;
      chart.data.datasets[0].data = tempArr;
      chart.data.datasets[1].data = soilArr;
      chart.data.datasets[2].data = phArr;
      chart.update();
    }

    // Tambahkan titik live ketika MQTT datang
    function appendLivePoint(type, value){
      const ts = new Date().toLocaleTimeString();
      if (historicalData.timestamps.length===0 || historicalData.timestamps.at(-1)!==ts){
        historicalData.timestamps.push(ts);
        historicalData.temperature.push(null);
        historicalData.humidity.push(null);
        historicalData.ph.push(null);
      }
      const idx = historicalData.timestamps.length-1;
      if (type==='temperature') historicalData.temperature[idx]=value;
      if (type==='humidity')    historicalData.humidity[idx]=value;
      if (type==='ph')          historicalData.ph[idx]=value;
    }

    // Ambil data historical dari API (1H/6H/24H dari realtime, 7D dari hourly)
    async function fetchHistorical(range){
      try{
        let labels=[], temp=[], soil=[], ph=[];
        if (range==='7d'){
          const url = API_PATH.hourly(7);
          const res = await fetch(url); const js = await res.json();
          if (js.ok){
            js.data.forEach(row=>{
              labels.push(new Date(row.hour_start*1000).toLocaleString());
              ph.push(row.ph_avg ?? null);
              soil.push(row.soil_avg ?? null);
              temp.push(row.temp_avg ?? null);
            });
          }
        } else {
          const hours = (range==='1h')?1 : (range==='6h')?6 : 24;
          const url = API_PATH.realtime(hours);
          const res = await fetch(url); const js = await res.json();
          if (js.ok){
            js.data.forEach(row=>{
              labels.push(new Date(row.t*1000).toLocaleTimeString());
              temp.push(row.suhu ?? null);
              soil.push(row.kelembapan_tanah ?? null);
              ph.push(row.pH ?? null);
            });
          }
        }
        setChartData(labels, temp, soil, ph);
      } catch(e){ console.error('fetchHistorical error', e); }
    }
  </script>
</body>
</html>
